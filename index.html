<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mobile ASCII Art (2× Wider, 9:16 Portrait)</title>
  <style>
    body {
      background: black;
      color: white;
      font-family: monospace;
      text-align: center;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    /* The container now is 360x640 pixels (doubled in both dimensions to preserve a 9:16 ratio) */
    #asciiContainer {
      width: 360px;
      height: 640px;
      border: 2px solid white;
      margin-top: 10px;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    /* Adjust the font size so the ASCII grid fits nicely.
       With the increased resolution (more grid cells), a smaller font works better. */
    pre#asciiOutput {
      margin: 0;
      /* Try 8px or tweak as needed */
      font-size: 8px;
      line-height: 8px;
    }
    button {
      font-size: 16px;
      padding: 10px;
      margin: 10px;
    }
    /* Hide the video element off-screen */
    video {
      position: absolute;
      left: -9999px;
    }
  </style>
</head>
<body>
  <button id="switchCamera">Switch Camera</button>
  <div id="asciiContainer">
    <pre id="asciiOutput">Loading...</pre>
  </div>

  <script>
    // A string of characters ordered by increasing "density".
    const density = " .:-=+*#%@";

    // Create and configure the video element.
    const video = document.createElement("video");
    video.autoplay = true;
    video.playsInline = true;
    video.muted = true; // Required for mobile autoplay.
    document.body.appendChild(video);

    // Create an offscreen canvas with fixed dimensions of 360x640 (9:16 portrait).
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    const CANVAS_WIDTH = 360;
    const CANVAS_HEIGHT = 640;
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;

    const asciiOutput = document.getElementById("asciiOutput");
    const switchButton = document.getElementById("switchCamera");

    let useFrontCamera = false;
    let stream;

    async function initCamera() {
      // Stop any existing stream.
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
      }
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: useFrontCamera ? "user" : "environment" }
        });
        video.srcObject = stream;
        video.onloadedmetadata = async () => {
          await video.play();
          requestAnimationFrame(drawFrame);
        };
      } catch (error) {
        console.error("Error accessing camera:", error);
        asciiOutput.textContent = "Error: Camera not accessible";
      }
    }

    function drawFrame() {
      // Ensure video dimensions are available.
      if (!video.videoWidth || !video.videoHeight) {
        requestAnimationFrame(drawFrame);
        return;
      }
      
      // Determine if the raw video feed is rotated.
      // Many mobile cameras output a landscape feed even when held in portrait.
      let rotate = false;
      if (video.videoWidth > video.videoHeight) {
        rotate = true;
      }
      
      // For rotated feeds, swap effective dimensions.
      let effectiveWidth = rotate ? video.videoHeight : video.videoWidth;
      let effectiveHeight = rotate ? video.videoWidth : video.videoHeight;
      
      // Our target aspect ratio is that of the canvas: 360/640.
      const targetAspect = CANVAS_WIDTH / CANVAS_HEIGHT;  // 360/640 = 0.5625
      
      // Calculate a source rectangle (sx, sy, sWidth, sHeight) from the video feed
      // that preserves its aspect ratio and fills the canvas without stretching.
      let sx, sy, sWidth, sHeight;
      if ((effectiveWidth / effectiveHeight) > targetAspect) {
        // The effective video is wider than our target: crop left/right.
        sHeight = effectiveHeight;
        sWidth = effectiveHeight * targetAspect;
        sx = (effectiveWidth - sWidth) / 2;
        sy = 0;
      } else {
        // The effective video is taller than our target: crop top/bottom.
        sWidth = effectiveWidth;
        sHeight = effectiveWidth / targetAspect;
        sx = 0;
        sy = (effectiveHeight - sHeight) / 2;
      }
      
      ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      ctx.save();
      if (rotate) {
        // Rotate the canvas -90° so that a landscape feed is shown in portrait.
        ctx.translate(0, CANVAS_HEIGHT);
        ctx.rotate(-90 * Math.PI / 180);
        // For the front camera, mirror the image horizontally.
        if (useFrontCamera) {
          ctx.translate(CANVAS_WIDTH, 0);
          ctx.scale(-1, 1);
        }
        // When rotated, swap the source rectangle coordinates.
        // (sx and sy come from the effective dimensions.)
        ctx.drawImage(video, sy, sx, sHeight, sWidth, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      } else {
        // No rotation is needed.
        if (useFrontCamera) {
          ctx.translate(CANVAS_WIDTH, 0);
          ctx.scale(-1, 1);
        }
        ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      }
      ctx.restore();

      // Convert the canvas image into ASCII.
      // We'll use a fixed grid.
      // Previously (for 180px width) we used 20 columns.
      // Now, with 360px width, we'll use 40 columns.
      const cols = 40;
      // Compute the number of rows such that cell dimensions remain consistent.
      const rows = Math.floor(CANVAS_HEIGHT / (CANVAS_WIDTH / cols));
      const cellWidth = Math.floor(CANVAS_WIDTH / cols);
      const cellHeight = Math.floor(CANVAS_HEIGHT / rows);
      let asciiImage = "";
      const imageData = ctx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      const pixels = imageData.data;
      
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          let total = 0, count = 0;
          for (let cy = 0; cy < cellHeight; cy++) {
            for (let cx = 0; cx < cellWidth; cx++) {
              const px = ((y * cellHeight + cy) * CANVAS_WIDTH + (x * cellWidth + cx)) * 4;
              if (px < pixels.length) {
                const r = pixels[px];
                const g = pixels[px + 1];
                const b = pixels[px + 2];
                total += (r + g + b) / 3;
                count++;
              }
            }
          }
          const brightness = total / count;
          const charIndex = Math.floor((brightness / 255) * (density.length - 1));
          asciiImage += density.charAt(charIndex);
        }
        asciiImage += "\n";
      }
      
      asciiOutput.textContent = asciiImage;
      requestAnimationFrame(drawFrame);
    }

    switchButton.addEventListener("click", () => {
      useFrontCamera = !useFrontCamera;
      initCamera();
    });

    initCamera();
  </script>
</body>
</html>
